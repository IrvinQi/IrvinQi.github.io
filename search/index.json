[{"content":"1 引入音乐播放器 【Aplayer官方文档】\n（1）在博客主目录中创建文件layouts\\partials\\footer\\custom.html，此文件为Stack主题作者留给我们加入自定义组件用的文件(可以查看主题源码同路径文件找到)\n（2）查看官方文档，引入对应的脚本，css到custom.html中，页面最下面就会出现音乐播放器\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;aplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const ap = new APlayer({ container: document.getElementById(\u0026#39;aplayer\u0026#39;), audio: [] }); \u0026lt;/script\u0026gt; （3）修改 ap对象 配置，改成吸底模式 1 2 3 4 5 const ap = new APlayer({ ..., // 吸底模式 fixed: true }); （4）填写audio数组，引入歌曲，封面和歌词 lrcType 的值具体看【文档】 歌曲，封面，歌词支持远程链接 or 本地路径 若想通过本地路径引入，请将资源文件放在static文件夹下，通过hugo方法{{ .Site.Home.Permalink }}，获取网站主路径来拼接文件路径，进行引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const staticDir = {{ .Site.Home.Permalink }} const ap = new APlayer({ ..., lrcType: 3, audio: [ { name: \u0026#39;name\u0026#39;, // 歌名 artist: \u0026#39;artist\u0026#39;, // 歌手 url: \u0026#39;url.mp3\u0026#39;, // 歌曲路径 cover: \u0026#39;cover.jpg\u0026#39;, // 封面路径 lrc: \u0026#39;lrc.lrc\u0026#39;, // 歌词路径 }, { // 本地路径引入写法（有子目录就在staticDir后面继续拼接） name: \u0026#39;name\u0026#39;, artist: \u0026#39;artist\u0026#39;, url: staticDir + \u0026#39;url.mp3\u0026#39;, cover: staticDir + \u0026#39;cover.jpg\u0026#39;, lrc: staticDir + \u0026#39;lrc.lrc\u0026#39;, } ] }); 2 音乐播放器样式切换 （1）通过阅读Stack主题的源码可以看到，主题样式的切换是通过[data-scheme=\u0026quot;light/darck\u0026quot;] {...}\n（2）所以我们可以准备两种Aplayer的css，用[data-scheme=\u0026quot;light\u0026quot;]{ 亮的css样式 }包裹亮的，用[data-scheme=\u0026quot;dark\u0026quot;]{ 暗的css样式 }包裹暗的，这里直接给各位准备好了\naplayer-light.scss（Ctrl+S保存） aplayer-dark.scss（Ctrl+S保存） （3）在博客主目录中创建文件assets\\scss\\custom.scss，此文件为Stack主题作者留给我们加入自定义样式用的文件(可以查看主题源码同路径文件找到)\n（4）将上述两个scss文件放到跟 custom.scss同目录下，并通过@import来进行引入文件\n1 2 3 4 5 /** * 【custom.scss】 */ @import \u0026#34;aplayer-light.scss\u0026#34;; @import \u0026#34;aplayer-dark.scss\u0026#34;; （5）因为音乐播放器的css改为我们本地文件引入了，所以 custom.html 中的link标签可以将它注释掉或者删掉了 3 音乐播放进度保留 （1）实现思路：页面切换前，把歌曲的 歌曲序号，播放时长，播放状态 记录下来；在页面切换加载完之后，我们调用Aplayer的接口切换歌曲，调整时长，并选择播放or暂停\n（2）通过console.log(ap)打印ap对象，或者官方文档，可以找到我们需要的参数\nlist.index：歌曲序号 audio.currentTime：播放时长 paused ：播放状态（是否暂停） （3）通过【官方文档】可以查找到我们需要调用的接口\nap.list.switch(index: number)：切换歌曲 ap.seek(time: number)：调整时长 ap.play()：播放歌曲 （4）需要的东西已经找齐，只需在 custom.html 加入以下代码即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... /** * 页面销毁前监听 */ window.onbeforeunload = () =\u0026gt; { // 将播放信息用对象封装，并存入到localStorage中 const playInfo = { index: ap.list.index, currentTime: ap.audio.currentTime, paused: ap.paused }; localStorage.setItem(\u0026#34;playInfo\u0026#34;, JSON.stringify(playInfo)); }; /** * 页面加载后监听 */ window.onload = () =\u0026gt; { // 从localStorage取出播放信息 const playInfo = JSON.parse(localStorage.getItem(\u0026#34;playInfo\u0026#34;)); if (!playInfo) { return; } // 切换歌曲 ap.list.switch(playInfo.index); // 等待500ms再执行下一步(切换歌曲需要点时间，不能立马调歌曲进度条) setTimeout(() =\u0026gt; { // 调整时长 ap.seek(playInfo.currentTime); // 是否播放 if (!playInfo.paused) { ap.play() } }, 500); }; \u0026lt;/script\u0026gt; 4 引入PJAX 4.1 基本引入 （1）PJAX主要分为两个版本，带JQuery 和 不带JQuery的，下面我演示的是不带JQuery版本的\n【defunkt/jquery-pjax】（带JQuery） 【MoOx/pjax】（不带JQuery） （2）分析页面元素，看哪些是需要我们重新加载的，可以发现是左侧边栏，中间内容，右侧边栏\n（3）查看页面源代码，可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着，所以我们将这元素定为要刷新的对象\n（4）根据官方文档，在 custom.html 加入以下代码来引入PJAX 1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 4.2 文章样式修复 （1）随便点进其中一篇文章，可以发现文章内容的样式丢失，缺少文章该有的边框 （2）通过手动刷新，对比页面元素发现，决定文章样式的是\u0026lt;body\u0026gt; 标签中的class名: article-page，存在此class名就会识别到文章该有的css （3）因为\u0026lt;body\u0026gt;内包含整个页面的所有内容，包括我们的音乐播放器，所以不能让PJAX监听\u0026lt;body\u0026gt;标签 阅读官方文档发现，官方提供了数据预处理方法，让我们处理数据 我们通过预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) // 放行，交给pjax自己处理 pjax._handleResponse(responseText, request, href, options); } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 这样我们切页面后，都会自动把body中的className更新，就不会丢失样式了\n4.3 主题切换修复 （1）当我们切换页面后，点击左下角切换主题颜色的按钮，会发现没有效果，主题颜色切换失效了\n（2）阅读Stack主题源码\\assets\\ts\\colorScheme.ts发现，在脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但该元素没有重新绑定点击事件，导致点击主题切换失效\n（3）解决思路：在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件。\n阅读源码，发现colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了个全局变量 Stack\n所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件\n阅读PJAX文档，发现官方也提供了PJAX执行完后的事件，我们执行监听这个事件，Stack 执行初始化就好\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 4.4 文章搜索修复 （1）使用文章搜索功能时，输入关键词，无任何搜索记录，搜索功能失效\n（2）查看layouts\\ts\\search.tsx文件，发现情况和上面的colorScheme.ts类似，存在绑定事件\n（3）解决思路类似上面的，把 search.tsx 初始化内容，封装为一个函数，并把函数 export 出来，由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 - （以下操作请复制同路径同名文件到自己主目录下修改，不要在主题源码中修改）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 【search.tsx】 * 记得把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【main.ts】 */ ... import { searchInit } from \u0026#34;ts/search\u0026#34;; let Stack = { init: () =\u0026gt; { ... // 调用search脚本初始化方法 searchInit(); } } （4）tsx 类型的文件引入方式有点特殊，需要我们修改以下 main.ts 的引入方式，修改layouts\\partials\\footer\\components\\script.html，改法参考layouts\\page\\search.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充上就好 4.5 搜索内容跳转修复 （1）虽然文章搜索已经修复了，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新了 （2）阅读 search.tsx 源码可知，搜索内容的数据，是通过 React.render() ，动态渲染回页面的，这些动态数据没有被PJAX识别到。阅读PJAX文档，官方提供给了我们重新解析数据的方法，所以在 React.render() 之后，调用PJAX方法，重新解析页面即可 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【search.tsx】 */ private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } 这样动态渲染出的页面数据就能被PJAX识别到，就不会刷新页面跳转了\n4.6 文章评论修复 （1）如果博客有开启评论功能的话，会发现评论的脚本不生效了 （2）由于每个人使用的评论种类各不相同，所以这边也是简单说一下。PJAX官方文档也有说如何处理： 用一个\u0026lt;div class=js-Pjax\u0026gt;\u0026lt;/div\u0026gt;来包裹一个\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 在\u0026lt;script\u0026gt;标签中，通过document.createElement('script')形式，创建对应的评论脚本内容 pjax对象通过 .js-Pjax 被识别到此内容，进行脚本执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- custom.thml --\u0026gt; ... \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // TODO: 判断当前是否是文档，且是否开启评论功能 (function() { let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); ... // 寻找合适的元素，添加脚本进去 document.querySelector(\u0026#39;xxx\u0026#39;).appendchild(script) })(document) \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 5 引入进度条 （1）由于使用了PJAX后，无法得知页面的加载情况是否完成，所以引入一个伪进度条，来显示页面内容进度 （2）前往【topbar】，点击下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js （3）通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--custom.html--\u0026gt; ... {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { .... // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; 这样伪进度条就成功引入了，能大概知道页面的加载情况了\n","date":"2025-01-18T19:10:13+08:00","image":"https://IrvinQi.github.io/p/hugoaplayer--pjax/APlayer_hu8840407507704973113.png","permalink":"https://IrvinQi.github.io/p/hugoaplayer--pjax/","title":"【Hugo】APlayer + PJAX "},{"content":"卡巴斯基网络威胁地图 卡巴斯基网络威胁地图是一个强大的工具，它提供了实时的全球网络安全态势信息，帮助用户了解不同地区的威胁分布情况，并采取相应的防御措施。通过该地图，用户可以更加直观地了解网络安全问题的严重性，从而加强自身的安全防护能力。\n网址：https://cybermap.kaspersky.com/cn\nPapers With Code Reddit用户rstoj做了一个网站，将ArXiv上的最新机器学习论文与GitHub上的代码（TensorFlow/PyTorch/MXNet /等）对应起来。你可以按标题关键词查询，也可以按流行程度、GitHub星星数排列“热门研究”。这个网站能让你跟上ML社区流行的最新动态。\n网址：https://paperswithcode.com\ntophix 一个综合性工具集合站，旨在为用户提供广泛的工具和资源，涵盖了多个领域和需求\n网址：https://tophix.com/zh-cn/\nAI工具集 一个AI工具整合网站\n网址：https://ai-bot.cn/\n","date":"2025-01-18T00:00:00Z","image":"https://IrvinQi.github.io/p/%E8%AE%B0%E5%BD%95links%E6%9B%B4%E6%96%B0/wangluoweixie_hu4586245457379409747.png","permalink":"https://IrvinQi.github.io/p/%E8%AE%B0%E5%BD%95links%E6%9B%B4%E6%96%B0/","title":"记录：Links更新"},{"content":"修改stack主题 hugo.yaml\nbaseurl：\n页面文章数量：\npagination: pagerSize: 5\n默认语言：简中\nDefaultContentLanguage: zh-cn\n#如果DefaultContentLanguage在[zh-cn ja ko]中，则将hasCJKLanguage设置为true #这将使。summary和。wordcount在CJK语言中表现正确。\nhasCJKLanguage: true\nlanguages: zh-cn: languageName: 简体中文 title: Irvin-玖柒 weight: 1 params: sidebar: subtitle: 热爱可抵漫长岁月，风起风止我都在 en: languageName: English title: Irvin-玖柒 weight: 2 params: sidebar: subtitle: Meeting is a sign, even if the outcome is not satisfactory. ja: languageName: にっぽん ご # languagedirection: rtl title: Irvin-玖柒 weight: 3 params: sidebar: subtitle: 花を着て山河を渡るとついに君と出会う 网站图标\nfavicon: /favicon.ico e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) 自定义文本\ncustomText\nfooter: since: 2025 customText: 日期修改\ndateFormat: published: 2006-01-02 个人\nsidebar: emoji: 🍥 subtitle: 热爱可抵漫长岁月，风起风止我都在 avatar: enabled: true local: true src: img/my.jpg ","date":"2025-01-17T16:46:39+08:00","permalink":"https://IrvinQi.github.io/p/stackedit/","title":"Stackedit"},{"content":"","date":"2025-01-17T00:00:00Z","permalink":"https://IrvinQi.github.io/p/myfirstblog/","title":"MyFirstBlog"}]